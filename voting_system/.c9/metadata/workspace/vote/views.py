{"changed":false,"filter":false,"title":"views.py","tooltip":"/vote/views.py","value":"from django.shortcuts import get_object_or_404, render\nfrom django.views import generic\nfrom django.http import HttpResponse, HttpResponseRedirect\nfrom django.core.urlresolvers import reverse\nfrom django.utils import timezone\nfrom django.core import serializers\n\nfrom .models import Choice, Question\n\nclass IndexView(generic.ListView):\n    template_name = 'vote/index.html'\n    context_object_name = 'latest_question_list'\n\n    def get_queryset(self):\n        \"\"\"\n        Return the last five published questions (not including those set to be\n        published in the future).\n        \"\"\"\n        return Question.objects.filter(\n        pub_date__lte=timezone.now()\n        ).order_by('-pub_date')[:5]\n\n\nclass DetailView(generic.DetailView):\n    model = Question\n    template_name = 'vote/detail.html'\n\n\nclass ResultsView(generic.DetailView):\n    model = Question\n    template_name = 'vote/results.html'\n    \n\ndef vote(request, question_id):\n    question = get_object_or_404(Question, pk=question_id)\n    try:\n        selected_choice = question.choice_set.get(pk=request.POST['choice'])\n    except (KeyError, Choice.DoesNotExist):\n        # Redisplay the question voting form.\n        return render(request, 'vote/detail.html', {\n            'question': question,\n            'error_message': \"You didn't select a choice.\",\n        })\n    else:\n        selected_choice.votes += 1\n        selected_choice.save()\n        # Always return an HttpResponseRedirect after successfully dealing\n        # with POST data. This prevents data from being posted twice if a\n        # user hits the Back button.\n        return HttpResponseRedirect(reverse('vote:results', args=(question.id,)))\n        \ndef ajaxRequest(request):\n    \"\"\"\n    Responses to POST requests, fetches data from the database about the question,\n    serialises it and returns it in a JSON form\n    \"\"\"\n    if request.method == 'POST':\n        question_id = request.POST.get('question_id', None)\n        get_data = Choice.objects.filter(question=question_id)\n        ser_data = serializers.serialize(\"json\", get_data)\n\n        return HttpResponse(ser_data, content_type=\"application/json\")\n    \ndef ajaxReply(request):\n    \"\"\"\n    Receives data from POST requests and adds it to the database\n    \"\"\"\n    if request.method == 'POST':\n        question_name = request.POST.get('que', None)\n        choice1 = request.POST.get('cho', None)\n        choice2 = request.POST.get('cho2', None)\n        choice3 = request.POST.get('cho3', None)\n        if Question.objects.filter(question_text=question_name).exists():\n                    return render(request, 'vote/index.html', {\n        'error_message': \"This question already exists.\",\n                    })\n        else:            \n            question = Question(question_text=question_name, pub_date=timezone.now())\n            question.save()\n            question = Question.objects.get(question_text=question_name)\n            choice = Question.objects.get(pk=question.id)\n            choice.choice_set.create(choice_text=choice1, votes=0)\n            choice.choice_set.create(choice_text=choice2, votes=0)\n            choice.choice_set.create(choice_text=choice3, votes=0)\n            return HttpResponseRedirect(reverse('vote:detail' ,args=(question.id,)))\n","undoManager":{"mark":-1,"position":-1,"stack":[]},"ace":{"folds":[],"scrolltop":1500,"scrollleft":0,"selection":{"start":{"row":85,"column":0},"end":{"row":85,"column":0},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":61,"state":"start","mode":"ace/mode/python"}},"timestamp":1509001648061}